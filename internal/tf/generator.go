package tf

import (
	"fmt"
	"os"
	"strings"

	"github.com/DrSkyle/cloudslash/internal/graph"
)

type Generator struct {
	Graph *graph.Graph
	State *State // Optional: For reverse lookup
}

func NewGenerator(g *graph.Graph, s *State) *Generator {
	return &Generator{Graph: g, State: s}
}

// GenerateWasteTF generates the waste.tf file containing resource blocks.
func (g *Generator) GenerateWasteTF(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue // Skip non-terraformable resources
		}

		// Use ID as the resource name (sanitized)
		tfName := sanitizeName(id)

		fmt.Fprintf(f, "resource \"%s\" \"%s\" {\n", tfType, tfName)
		// We don't need full config for import, just enough to pass validation if possible.
		// Usually empty block is enough for import, but `terraform plan` might complain.
		// For "Reverse Terraform", we ideally want to reconstruct the config.
		// For now, we'll write minimal config or comments.
		fmt.Fprintf(f, "  # Imported by CloudSlash (Risk Score: %d)\n", node.RiskScore)
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "  # Reason: %s\n", reason)
		}
		fmt.Fprintf(f, "}\n\n")
	}
	return nil
}

// GenerateImportScript generates the import.sh script.
func (g *Generator) GenerateImportScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "# Generated by CloudSlash\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue
		}

		tfName := sanitizeName(id)

		// Extract actual ID from ARN or use ARN depending on resource
		resourceID := extractResourceID(id, node.Type)

		fmt.Fprintf(f, "terraform import %s.%s %s\n", tfType, tfName, resourceID)
	}
	return nil
}

// GenerateDestroyPlan generates a human-readable report.
func (g *Generator) GenerateDestroyPlan(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "CloudSlash Destruction Plan\n")
	fmt.Fprintf(f, "===========================\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	totalWaste := 0
	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}
		totalWaste++

		fmt.Fprintf(f, "[%d] %s (%s)\n", node.RiskScore, id, node.Type)
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "    Reason: %s\n", reason)
		}

		// Special handling for S3 Multipart
		if node.Type == "AWS::S3::MultipartUpload" {
			bucket, _ := node.Properties["Bucket"].(string)
			key, _ := node.Properties["Key"].(string)
			uploadId, _ := node.Properties["UploadId"].(string)
			fmt.Fprintf(f, "    Command: aws s3api abort-multipart-upload --bucket %s --key \"%s\" --upload-id %s\n", bucket, key, uploadId)
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	return nil
}

// GenerateFixScript generates a script to remove waste from Terraform State.
func (g *Generator) GenerateFixScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "# Generated by CloudSlash\n")
	fmt.Fprintf(f, "# Generator: CloudSlash Open Core (CS-v1-7f8a9d-AGPL)\n")
	fmt.Fprintf(f, "# SAFETY: These commands remove items from Terraform STATE only.\n")
	fmt.Fprintf(f, "# They DO NOT delete the actual resource. You can safely delete the code after running this.\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	var stateMap map[string]string
	if g.State != nil {
		stateMap = g.State.GetResourceMapping()
	}

	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue
		}

		// Try to find exact Terraform Address from State
		// First try ID, then try extracting resource ID
		resourceName := ""
		
		if addr, ok := stateMap[id]; ok {
			resourceName = addr
		} else {
			// Try shortened ID
			shortID := extractResourceID(id, node.Type)
			if addr, ok := stateMap[shortID]; ok {
				resourceName = addr
			}
		}

		fmt.Fprintf(f, "# Waste: %s (%s)\n", id, node.Properties["Reason"])
		if resourceName != "" {
			fmt.Fprintf(f, "terraform state rm %s\n", resourceName)
		} else {
			fmt.Fprintf(f, "# ⚠️ Could not find in local .tfstate. Suggested command if you know the name:\n")
			fmt.Fprintf(f, "# terraform state rm %s.<NAME>\n", tfType)
		}
		fmt.Fprintf(f, "\n")
	}
	return nil
}

func mapResourceTypeToTF(awsType string) string {
	switch awsType {
	case "AWS::EC2::Instance":
		return "aws_instance"
	case "AWS::EC2::Volume":
		return "aws_ebs_volume"
	case "AWS::EC2::NatGateway":
		return "aws_nat_gateway"
	case "AWS::EC2::EIP":
		return "aws_eip"
	case "AWS::S3::Bucket":
		return "aws_s3_bucket"
	default:
		return ""
	}
}

func sanitizeName(id string) string {
	// arn:aws:ec2:region:account:instance/i-12345 -> i_12345
	parts := strings.Split(id, "/")
	if len(parts) > 1 {
		return strings.ReplaceAll(parts[len(parts)-1], "-", "_")
	}
	return strings.ReplaceAll(id, ":", "_")
}

func extractResourceID(arn, awsType string) string {
	// Simplified extraction
	parts := strings.Split(arn, "/")
	if len(parts) > 1 {
		return parts[len(parts)-1]
	}
	return arn
}
