package tf

import (
	"fmt"
	"os"
	"strings"

	"github.com/DrSkyle/cloudslash/internal/graph"
)

type Generator struct {
	Graph *graph.Graph
	State *State // Optional: For reverse lookup
}

func NewGenerator(g *graph.Graph, s *State) *Generator {
	return &Generator{Graph: g, State: s}
}

// GenerateWasteTF generates the waste.tf file containing resource blocks.
func (g *Generator) GenerateWasteTF(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue // Skip non-terraformable resources
		}

		// Use ID as the resource name (sanitized)
		tfName := sanitizeName(id)

		fmt.Fprintf(f, "resource \"%s\" \"%s\" {\n", tfType, tfName)
		// We don't need full config for import, just enough to pass validation if possible.
		// Usually empty block is enough for import, but `terraform plan` might complain.
		// For "Reverse Terraform", we ideally want to reconstruct the config.
		// For now, we'll write minimal config or comments.
		fmt.Fprintf(f, "  # Imported by CloudSlash (Risk Score: %d)\n", node.RiskScore)
		if isGP2, _ := node.Properties["IsGP2"].(bool); isGP2 {
			fmt.Fprintf(f, "  type = \"gp3\"\n")
		}
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "  # Reason: %s\n", reason)
		}
		fmt.Fprintf(f, "}\n\n")
	}
	return nil
}

// GenerateImportScript generates the import.sh script.
func (g *Generator) GenerateImportScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "# Generated by CloudSlash\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue
		}

		tfName := sanitizeName(id)

		// Extract actual ID from ARN or use ARN depending on resource
		resourceID := extractResourceID(id, node.Type)

		fmt.Fprintf(f, "terraform import %s.%s %s\n", tfType, tfName, resourceID)
	}
	return nil
}

// GenerateDestroyPlan generates a human-readable report.
func (g *Generator) GenerateDestroyPlan(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "CloudSlash Destruction Plan\n")
	fmt.Fprintf(f, "===========================\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	totalWaste := 0
	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}
		totalWaste++

		fmt.Fprintf(f, "[%d] %s (%s)\n", node.RiskScore, id, node.Type)
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "    Reason: %s\n", reason)
		}

		// Special handling for S3 Multipart
		if node.Type == "AWS::S3::MultipartUpload" {
			bucket, _ := node.Properties["Bucket"].(string)
			key, _ := node.Properties["Key"].(string)
			uploadId, _ := node.Properties["UploadId"].(string)
			fmt.Fprintf(f, "    Command: aws s3api abort-multipart-upload --bucket %s --key \"%s\" --upload-id %s\n", bucket, key, uploadId)
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	return nil
}

// GenerateFixScript generates a script to remove waste from Terraform State.
func (g *Generator) GenerateFixScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// SSSS+ Safe Template
	fmt.Fprintf(f, `#!/bin/bash
set -e
set -o pipefail

# CLOUDSLASH REMEDIATION SCRIPT (v1.3.0)
# Risk Level: SURGICAL (Modifies Terraform State)

RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${RED}[WARN] This script will remove Zombie resources from your Terraform State.${NC}"
echo "       It does NOT delete the resource from AWS. It only stops Terraform from tracking it."
echo "       This allows you to safely delete the resource in the AWS Console without 'State Drift' errors."
echo ""
read -p "Are you sure you want to proceed? (y/N) " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
fi

# 1. PRE-FLIGHT CHECKS
echo -e "\n${CYAN}[1/3] Pre-flight Checks...${NC}"
if ! command -v terraform &> /dev/null; then
    echo "Error: 'terraform' binary not found."
    exit 1
fi

if [ ! -f "terraform.tfstate" ] && [ ! -d ".terraform" ]; then
    echo "Error: No Terraform state found in current directory."
    exit 1
fi

# 2. SAFETY BACKUP
BACKUP_FILE="tfstate_backup_$(date +%%s).json"
echo -e "${CYAN}[2/3] Creating Safety Backup (${BACKUP_FILE})...${NC}"
terraform state pull > "$BACKUP_FILE"
echo "      Backup secure."

# 3. SURGICAL REMOVAL
echo -e "${CYAN}[3/3] Removing Zombies...${NC}"

# --- GENERATED COMMANDS START HERE ---
`)

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	var stateMap map[string]string
	if g.State != nil {
		stateMap = g.State.GetResourceMapping()
	}

	for id, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		// Skip logical upgrades (handled by waste.tf -> terraform plan)
		if isGP2, _ := node.Properties["IsGP2"].(bool); isGP2 {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue
		}

		// Try to find exact Terraform Address from State
		resourceName := ""

		if addr, ok := stateMap[id]; ok {
			resourceName = addr
		} else {
			// Try shortened ID
			shortID := extractResourceID(id, node.Type)
			if addr, ok := stateMap[shortID]; ok {
				resourceName = addr
			}
		}

		fmt.Fprintf(f, "echo \" -> Removing %s (%s)...\"\n", id, node.Properties["Reason"])
		if resourceName != "" {
			fmt.Fprintf(f, "terraform state rm '%s' || echo \"    (Resource not found in state, skipping)\"\n", resourceName)
		} else {
			fmt.Fprintf(f, "# ⚠️ Could not find in local .tfstate. Suggested command:\n")
			fmt.Fprintf(f, "# terraform state rm %s.<NAME>\n", tfType)
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, `# --- GENERATED COMMANDS END HERE ---

echo -e "\n${GREEN}[SUCCESS] State Surgery Complete.${NC}"
echo "Next Step: Run 'terraform plan' to verify the clean state."
`)
	return nil
}

func mapResourceTypeToTF(awsType string) string {
	switch awsType {
	case "AWS::EC2::Instance":
		return "aws_instance"
	case "AWS::EC2::Volume":
		return "aws_ebs_volume"
	case "AWS::EC2::NatGateway":
		return "aws_nat_gateway"
	case "AWS::EC2::EIP":
		return "aws_eip"
	case "AWS::S3::Bucket":
		return "aws_s3_bucket"
	default:
		return ""
	}
}

func sanitizeName(id string) string {
	// arn:aws:ec2:region:account:instance/i-12345 -> i_12345
	parts := strings.Split(id, "/")
	if len(parts) > 1 {
		return strings.ReplaceAll(parts[len(parts)-1], "-", "_")
	}
	return strings.ReplaceAll(id, ":", "_")
}

func extractResourceID(arn, awsType string) string {
	// Simplified extraction
	parts := strings.Split(arn, "/")
	if len(parts) > 1 {
		return parts[len(parts)-1]
	}
	return arn
}
