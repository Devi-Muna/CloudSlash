package pricing

import (
	"context"
	"encoding/json"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"testing"
	"time"
)

// Mission 3: The "Time-Travel" Pricing Test
// The Goal: Verify the "Hybrid Estimation" math works correctly when the cache is 1 minute old vs. 25 hours old.

func TestCacheExpiration(t *testing.T) {
	// Setup isolated environment
	tmpDir := t.TempDir()
	// Disable logging noise
	logger := slog.New(slog.NewTextHandler(io.Discard, nil))

	// Create Calibrator
	// Override is 0 to ensure we rely on cache/fetch logic
	c := NewCalibrator(logger, tmpDir, 0)
	ctx := context.Background()

	cacheFile := filepath.Join(tmpDir, "discounts.json")

	// -------------------------------------------------------------------------
	// Scenario 1: The "Time Capsule" (Stale Cache)
	// -------------------------------------------------------------------------
	// We plant a cache file from the "past" (25 hours ago).
	// It has a unique factor (0.42) that is unlikely to be generated by the fallback (1.0).

	staleTime := time.Now().Add(-25 * time.Hour).Unix()
	staleData := DiscountCache{
		Factor:    0.42,
		Timestamp: staleTime,
	}
	writeCache(t, cacheFile, staleData)

	// Action: Ask for discount factor.
	// Expectation: Cache is expired -> Calls AWS -> Fails (No Creds) -> Returns Fallback (1.0).
	// Proof: The value IS NOT 0.42.

	factor := c.GetDiscountFactor(ctx)
	if factor == 0.42 {
		t.Fatalf("CRITICAL: Stale cache was used! Logic failed to invalidate 25h old data.")
	}
	if factor != 1.0 {
		// If you have real AWS creds this might be different, but in pure unit test environment
		// without env vars, it should be 1.0.
		// t.Logf("Note: AWS Fetch returned %f (Environment might be active)", factor)
	} else {
		t.Log("Success: Stale cache invalidated. (Fallback 1.0 returned)")
	}

	// -------------------------------------------------------------------------
	// Scenario 2: The "Fresh Baked" (Valid Cache)
	// -------------------------------------------------------------------------
	// We plant a cache file from "now" (1 hour ago).

	freshTime := time.Now().Add(-1 * time.Hour).Unix()
	freshData := DiscountCache{
		Factor:    0.42,
		Timestamp: freshTime,
	}
	writeCache(t, cacheFile, freshData)

	// Action: Ask again.
	// Expectation: Cache is valid -> Returns 0.42 immediately. Without touching AWS.

	factor2 := c.GetDiscountFactor(ctx)
	if factor2 != 0.42 {
		t.Fatalf("CRITICAL: Fresh cache was ignored! Expected 0.42, got %f", factor2)
	}
	t.Log("Success: Fresh cache used.")
}

func writeCache(t *testing.T, path string, data DiscountCache) {
	bytes, err := json.Marshal(data)
	if err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(path, bytes, 0644); err != nil {
		t.Fatal(err)
	}
}
