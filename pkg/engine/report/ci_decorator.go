package report

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/DrSkyle/cloudslash/pkg/graph"
)

// CIDecorator manages integration with CI/CD environments.
type CIDecorator struct {
	logger   *slog.Logger
	Provider string // "github", "gitlab", or ""
}

// NewCIDecorator initializes the decorator based on the environment.
func NewCIDecorator(logger *slog.Logger) *CIDecorator {
	if logger == nil {
		logger = slog.New(slog.NewTextHandler(io.Discard, nil))
	}

	provider := ""
	if os.Getenv("GITHUB_ACTIONS") == "true" {
		provider = "github"
	}
	if os.Getenv("GITLAB_CI") == "true" {
		provider = "gitlab"
	}
	return &CIDecorator{
		logger:   logger,
		Provider: provider,
	}
}

// Run executes reporting logic (summary and comments).
func (d *CIDecorator) Run(summary Summary, g *graph.Graph) error {
	if d.Provider == "" {
		return nil // Not in CI
	}

	markdown := d.generateMarkdown(summary, g)

	// Writing to Step Summary.
	if d.Provider == "github" {
		if err := d.appendGitHubStepSummary(markdown); err != nil {
			d.logger.Error("Failed to write step summary", "error", err)
		}

		// Posting PR Comment.
		// Only run if we are in a PR context and have a token.
		token := os.Getenv("GITHUB_TOKEN")
		if token != "" {
			prID, err := d.detectGitHubPR()
			if err == nil && prID != "" {
				if err := d.manageGitHubComment(token, prID, markdown); err != nil {
					d.logger.Error("Failed to post PR comment", "error", err)
				}
			}
		}
	} else if d.Provider == "gitlab" {
		// Posting MR Note.
		token := os.Getenv("GITLAB_TOKEN")
		if token != "" {
			if err := d.manageGitLabComment(token, markdown); err != nil {
				d.logger.Error("Failed to post GitLab MR note", "error", err)
			}
		} else {
			d.logger.Info("GitLab detected. Set GITLAB_TOKEN to enable MR decoration.")
		}
	}

	return nil
}

func (d *CIDecorator) manageGitLabComment(token, content string) error {
	apiBase := os.Getenv("CI_API_V4_URL")
	if apiBase == "" {
		apiBase = "https://gitlab.com/api/v4"
	}
	
	projectID := os.Getenv("CI_PROJECT_ID")
	mrIID := os.Getenv("CI_MERGE_REQUEST_IID")
	
	if projectID == "" || mrIID == "" {
		return fmt.Errorf("not in a Merge Request context (missing CI_PROJECT_ID or CI_MERGE_REQUEST_IID)")
	}

	// Note: Appending new note for simplicity.
	// POST a new note (stateless).
	
	url := fmt.Sprintf("%s/projects/%s/merge_requests/%s/notes", apiBase, projectID, mrIID)
	
	payload := map[string]string{"body": content}
	payloadBytes, _ := json.Marshal(payload)
	
	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(payloadBytes))
	req.Header.Set("PRIVATE-TOKEN", token)
	req.Header.Set("Content-Type", "application/json")
	
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("API %s: %s", resp.Status, string(body))
	}
	
	d.logger.Info("Posted results to GitLab MR")
	return nil
}

func (d *CIDecorator) generateMarkdown(s Summary, g *graph.Graph) string {
	var sb strings.Builder

	sb.WriteString("### â˜ï¸ CloudSlash Infrastructure Audit\n\n")
	
	// KPI Table.
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("| :--- | :--- |\n")
	sb.WriteString(fmt.Sprintf("| **Total Waste** | `%d Resources` |\n", s.TotalWaste))
	sb.WriteString(fmt.Sprintf("| **Projected Savings** | `$%0.2f / mo` |\n", s.TotalSavings))
	sb.WriteString(fmt.Sprintf("| **Scanned Nodes** | `%d` |\n", s.TotalScanned))
	sb.WriteString("\n")

	if s.TotalWaste > 0 {
		sb.WriteString("#### âš ï¸ High-Impact Findings\n\n")
		sb.WriteString("| Resource | Type | Cost | Reason |\n")
		sb.WriteString("| :--- | :--- | :--- | :--- |\n")

		count := 0
		g.Mu.RLock()
		for _, n := range g.Nodes {
			if n.IsWaste {
				// Escape table formatting characters.
				reason := strings.ReplaceAll(n.WasteReason, "|", "\\|")
				sb.WriteString(fmt.Sprintf("| `%s` | %s | **$%.2f** | %s |\n", n.ID, n.Type, n.Cost, reason))
				count++
				if count >= 10 { // Limit table size
					break
				}
			}
		}
		g.Mu.RUnlock()
		if count < s.TotalWaste {
			sb.WriteString(fmt.Sprintf("\n*...and %d more.* ", s.TotalWaste-count))
		}
		sb.WriteString("\n\n")
	} else {
		sb.WriteString("âœ… **Infrastructure is clean.** No waste detected.\n\n")
	}

	sb.WriteString("---\n")
	sb.WriteString("ðŸ“Š **Full Dashboard:** Download the `cloudslash-dashboard.html` artifact from the **Summary** tab.\n")
	sb.WriteString(fmt.Sprintf("\n*Generated by CloudSlash at %s*\n", time.Now().Format(time.RFC3339)))

	return sb.String()
}

func (d *CIDecorator) appendGitHubStepSummary(content string) error {
	path := os.Getenv("GITHUB_STEP_SUMMARY")
	if path == "" {
		return nil
	}

	f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		d.logger.Error("Error opening summary file", "error", err)
		return err
	}
	defer f.Close()

	if _, err := f.WriteString(content + "\n"); err != nil {
		return err
	}
	return nil
}

func (d *CIDecorator) detectGitHubPR() (string, error) {
	// Parse GITHUB_REF: refs/pull/:id/merge
	ref := os.Getenv("GITHUB_REF")
	regex := regexp.MustCompile(`refs/pull/(\d+)/merge`)
	matches := regex.FindStringSubmatch(ref)
	if len(matches) > 1 {
		return matches[1], nil
	}
	// Fallback? could parse JSON event, but this is standard for PRs.
	return "", fmt.Errorf("not a PR ref")
}

func (d *CIDecorator) manageGitHubComment(token, prID, content string) error {
	repo := os.Getenv("GITHUB_REPOSITORY") // "owner/repo"
	if repo == "" {
		return fmt.Errorf("GITHUB_REPOSITORY not set")
	}
	
	apiBase := os.Getenv("GITHUB_API_URL")
	if apiBase == "" {
		apiBase = "https://api.github.com"
	}
	
	// 1. List Comments to find existing one
	// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
	listURL := fmt.Sprintf("%s/repos/%s/issues/%s/comments", apiBase, repo, prID)
	
	req, _ := http.NewRequest("GET", listURL, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Accept", "application/vnd.github+json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	var comments []map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&comments); err != nil {
		// Ignore decode error, might be empty body or 404
	}

	var commentID float64 
	for _, c := range comments {
		body, _ := c["body"].(string)
		if strings.Contains(body, "### â˜ï¸ CloudSlash Infrastructure Audit") {
			// Found our comment
			commentID, _ = c["id"].(float64)
			break
		}
	}

	payloadInfo := map[string]string{"body": content}
	payloadBytes, _ := json.Marshal(payloadInfo)

	var targetURL, method string
	if commentID != 0 {
		// PATCH
		targetURL = fmt.Sprintf("%s/repos/%s/issues/comments/%.0f", apiBase, repo, commentID)
		method = "PATCH"
		d.logger.Info("Updating existing PR Comment", "id", commentID)
	} else {
		// POST
		targetURL = fmt.Sprintf("%s/repos/%s/issues/%s/comments", apiBase, repo, prID)
		method = "POST"
		d.logger.Info("Posting new PR Comment")
	}

	req, _ = http.NewRequest(method, targetURL, bytes.NewBuffer(payloadBytes))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	
	resp2, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp2.Body.Close()
	
	if resp2.StatusCode >= 300 {
		body, _ := io.ReadAll(resp2.Body)
		return fmt.Errorf("API %s: %s", resp2.Status, string(body))
	}

	return nil
}
