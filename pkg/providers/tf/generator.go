package tf

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/DrSkyle/cloudslash/v2/pkg/config"
	"github.com/DrSkyle/cloudslash/v2/pkg/graph"
	"github.com/DrSkyle/cloudslash/v2/pkg/version"
)

type Generator struct {
	Graph *graph.Graph
	State *State // Optional: For reverse lookup against Terraform State addresses.
}

func NewGenerator(g *graph.Graph, s *State) *Generator {
	return &Generator{Graph: g, State: s}
}

var safeIDRegex = regexp.MustCompile("^[a-zA-Z0-9._/-]+$")

// GenerateWasteTF creates Terraform resource blocks for waste.
func (g *Generator) GenerateWasteTF(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for _, node := range g.Graph.GetNodes() {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.TypeStr())
		if tfType == "" {
			continue // Skip unsupported types.
		}

		// Generate sanitized resource name.
		tfName := sanitizeName(node.IDStr())

		fmt.Fprintf(f, "resource \"%s\" \"%s\" {\n", tfType, tfName)
		// Write import metadata.
		fmt.Fprintf(f, "  # Imported by CloudSlash (Risk Score: %d)\n", node.RiskScore)
		if isGP2, _ := node.Properties["IsGP2"].(bool); isGP2 {
			fmt.Fprintf(f, "  type = \"gp3\"\n")
		}
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "  # Reason: %s\n", reason)
		}
		fmt.Fprintf(f, "}\n\n")
	}
	return nil
}

// GenerateImportScript creates the import script.
func (g *Generator) GenerateImportScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "# Generated by CloudSlash\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for _, node := range g.Graph.GetNodes() {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.TypeStr())
		if tfType == "" {
			continue
		}

		tfName := sanitizeName(node.IDStr())

		// Resolve resource ID.
		resourceID := extractResourceID(node.IDStr(), node.TypeStr())
		if !safeIDRegex.MatchString(resourceID) {
			fmt.Fprintf(f, "# SKIP: unsafe resource ID detected: %s\n", resourceID)
			continue
		}

		fmt.Fprintf(f, "terraform import '%s.%s' '%s'\n", tfType, tfName, resourceID)
	}
	return nil
}

// GenerateDestroyPlan creates destruction report.
func (g *Generator) GenerateDestroyPlan(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "CloudSlash Destruction Plan\n")
	fmt.Fprintf(f, "===========================\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	totalWaste := 0
	for _, node := range g.Graph.GetNodes() {
		if !node.IsWaste {
			continue
		}
		totalWaste++

		fmt.Fprintf(f, "[%d] %s (%s)\n", node.RiskScore, node.IDStr(), node.TypeStr())
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "    Reason: %s\n", reason)
		}

		// Handle S3 Multipart Uploads.
		if node.TypeStr() == "AWS::S3::MultipartUpload" {
			bucket, _ := node.Properties["Bucket"].(string)
			key, _ := node.Properties["Key"].(string)
			uploadId, _ := node.Properties["UploadId"].(string)
			// Safety check
			if safeIDRegex.MatchString(bucket) && safeIDRegex.MatchString(key) && safeIDRegex.MatchString(uploadId) {
				fmt.Fprintf(f, "    Command: aws s3api abort-multipart-upload --bucket %s --key \"%s\" --upload-id %s\n", bucket, key, uploadId)
			}
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	return nil
}

// GenerateFixScript creates state removal script.
func (g *Generator) GenerateFixScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write script header.
	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "set -e\n")
	fmt.Fprintf(f, "set -o pipefail\n\n")

	fmt.Fprintf(f, "# CLOUDSLASH REMEDIATION SCRIPT (%s)\n", version.Current)
	fmt.Fprintf(f, "# Risk Level: SURGICAL (Modifies Terraform State)\n\n")

	fmt.Fprintf(f, `RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${RED}[WARN] This script will remove Zombie resources from your Terraform State.${NC}"
echo "       It does NOT delete the resource from AWS. It only stops Terraform from tracking it."
echo "       This allows you to safely delete the resource in the AWS Console without 'State Drift' errors."
echo ""
read -p "Are you sure you want to proceed? (y/N) " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
fi

# 1. PRE-FLIGHT CHECKS
echo -e "\n${CYAN}[1/3] Pre-flight Checks...${NC}"
if ! command -v terraform &> /dev/null; then
    echo "Error: 'terraform' binary not found."
    exit 1
fi

if [ ! -f "terraform.tfstate" ] && [ ! -d ".terraform" ]; then
    echo "Error: No Terraform state found in current directory."
    exit 1
fi

# 2. SAFETY BACKUP
BACKUP_FILE="tfstate_backup_$(date +%%s).json"
echo -e "${CYAN}[2/3] Creating Safety Backup (${BACKUP_FILE})...${NC}"
terraform state pull > "$BACKUP_FILE"
echo "      Backup secure."

# 3. SURGICAL REMOVAL
echo -e "${CYAN}[3/3] Removing Unused Resources...${NC}"

# --- GENERATED COMMANDS START HERE ---
`)

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	var stateMap map[string]string
	if g.State != nil {
		stateMap = g.State.GetResourceMapping()
	}

	for _, node := range g.Graph.GetNodes() {
		if !node.IsWaste {
			continue
		}

		// Skip logical upgrades.
		if isGP2, _ := node.Properties["IsGP2"].(bool); isGP2 {
			continue
		}

		tfType := mapResourceTypeToTF(node.TypeStr())
		if tfType == "" {
			continue
		}

		// Find resource address.
		resourceName := ""

		if addr, ok := stateMap[node.IDStr()]; ok {
			resourceName = addr
		} else {
			// Attempt shortened ID match.
			shortID := extractResourceID(node.IDStr(), node.TypeStr())
			if addr, ok := stateMap[shortID]; ok {
				resourceName = addr
			}
		}

		// Security Check: Ensure node ID is safe before echoing.
		if !safeIDRegex.MatchString(node.IDStr()) {
			fmt.Fprintf(f, "# SKIP: unsafe resource ID detected in graph: %s\n", node.IDStr())
			continue
		}

		// Sanitize/Quote the 'Reason' property to prevent injection if it contains quotes/shell chars.
		reason := "Waste identified"
		if r, ok := node.Properties["Reason"].(string); ok {
			// Basic sanitization: escape double quotes, remove newlines
			reason = strings.ReplaceAll(r, "\"", "\\\"")
			reason = strings.ReplaceAll(reason, "\n", " ")
		}

		fmt.Fprintf(f, "echo \" -> Removing %s (%s)...\"\n", node.IDStr(), reason)
		if resourceName != "" {
			// Check reasonable chars in resourceName (tf addresses are usually safe but minimal checking)
			// Generally strictly alphanumeric, dots, underscores, dashes, brackets.
			// Just quoting it should be enough for bash safety if we assume tf state keys aren't poisoned (riskier assumption but standard)
			// We can use single quotes.
			fmt.Fprintf(f, "terraform state rm '%s' || echo \"    (Resource not found in state, skipping)\"\n", resourceName)
		} else {
			fmt.Fprintf(f, "# Warning: Could not resolve address in local state. Suggested command:\n")
			fmt.Fprintf(f, "# terraform state rm '%s.<NAME>'\n", tfType)
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, `# --- GENERATED COMMANDS END HERE ---

echo -e "\n${GREEN}[SUCCESS] State Surgery Complete.${NC}"
echo "Next Step: Run 'terraform plan' to verify the clean state."
`)
	return nil
}

func mapResourceTypeToTF(awsType string) string {
	switch awsType {
	case "AWS::EC2::Instance":
		return "aws_instance"
	case "AWS::EC2::Volume":
		return "aws_ebs_volume"
	case "AWS::EC2::NatGateway":
		return "aws_nat_gateway"
	case "AWS::EC2::EIP":
		return "aws_eip"
	case "AWS::S3::Bucket":
		return "aws_s3_bucket"
	default:
		return ""
	}
}

func sanitizeName(id string) string {
	// Sanitize resource ID for Terraform name.
	parts := strings.Split(id, "/")
	if len(parts) > 1 {
		return strings.ReplaceAll(parts[len(parts)-1], "-", "_")
	}
	return strings.ReplaceAll(id, ":", "_")
}

func extractResourceID(arn, awsType string) string {
	// Extract suffix from ARN.
	parts := strings.Split(arn, "/")
	var id string
	if len(parts) > 1 {
		id = parts[len(parts)-1]
	} else {
		id = arn
	}

	// FAANG SAFETY CHECK
	if !safeIDRegex.MatchString(id) {
		return "UNSAFE_ID_DETECTED"
	}
	return id
}

// GenerateRestorationPlan creates restoration config.
// Generates Terraform import blocks.
// This allows the user to run 'terraform plan -generate-config-out=backup.tf' to snapshot
// the resource configuration into HCL before deletion.
func (g *Generator) GenerateRestorationPlan(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	fmt.Fprintf(f, "# CloudSlash Lazarus Protocol - Restoration Plan\n")
	fmt.Fprintf(f, "# Generated: %s\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(f, "# INSTRUCTIONS:\n")
	fmt.Fprintf(f, "# 1. Run 'terraform init'\n")
	fmt.Fprintf(f, "# 2. Run 'terraform plan -generate-config-out=lazarus_backup.tf'\n")
	fmt.Fprintf(f, "# 3. This will query AWS and save the CONFIGURATION of these resources to lazarus_backup.tf\n")
	fmt.Fprintf(f, "# 4. If you later need to 'Undo' a deletion, use the code in lazarus_backup.tf to recreate the resource.\n\n")

	fmt.Fprintf(f, "terraform {\n  required_version = \">= 1.5.0\"\n  required_providers {\n    aws = {\n      source = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\n")
	fmt.Fprintf(f, "provider \"aws\" {\n  region = \"%s\" # Default, override via env var if needed\n}\n\n", config.DefaultRegion)

	count := 0
	for _, node := range g.Graph.GetNodes() {
		if !node.IsWaste {
			continue
		}

		resourceID := extractResourceID(node.IDStr(), node.TypeStr())
		if resourceID == "UNSAFE_ID_DETECTED" {
			continue
		}

		tfType := mapResourceTypeToTF(node.TypeStr())

		if tfType != "" {
			// Sanitize ID.
			safeID := strings.ReplaceAll(resourceID, "-", "_")
			safeID = strings.ReplaceAll(safeID, ".", "_")
			safeID = strings.ReplaceAll(safeID, "/", "_")

			fmt.Fprintf(f, "import {\n")
			fmt.Fprintf(f, "  to = %s.restore_%s\n", tfType, safeID)
			fmt.Fprintf(f, "  id = \"%s\"\n", resourceID)
			fmt.Fprintf(f, "}\n\n")
			count++
		}
	}

	if count == 0 {
		fmt.Fprintf(f, "# No supported resources found for restoration.\n")
	}

	return nil
}
