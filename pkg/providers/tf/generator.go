package tf

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/DrSkyle/cloudslash/pkg/config"
	"github.com/DrSkyle/cloudslash/pkg/graph"
	"github.com/DrSkyle/cloudslash/pkg/version"
)

type Generator struct {
	Graph *graph.Graph
	State *State // Optional: For reverse lookup against Terraform State addresses.
}

func NewGenerator(g *graph.Graph, s *State) *Generator {
	return &Generator{Graph: g, State: s}
}

// GenerateWasteTF creates Terraform resource blocks for waste.
func (g *Generator) GenerateWasteTF(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for _, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue // Skip unsupported types.
		}

		// Generate sanitized resource name.
		tfName := sanitizeName(node.ID)

		fmt.Fprintf(f, "resource \"%s\" \"%s\" {\n", tfType, tfName)
		// Write import metadata.
		fmt.Fprintf(f, "  # Imported by CloudSlash (Risk Score: %d)\n", node.RiskScore)
		if isGP2, _ := node.Properties["IsGP2"].(bool); isGP2 {
			fmt.Fprintf(f, "  type = \"gp3\"\n")
		}
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "  # Reason: %s\n", reason)
		}
		fmt.Fprintf(f, "}\n\n")
	}
	return nil
}

// GenerateImportScript creates the import script.
func (g *Generator) GenerateImportScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "# Generated by CloudSlash\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	for _, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue
		}

		tfName := sanitizeName(node.ID)

		// Resolve resource ID.
		resourceID := extractResourceID(node.ID, node.Type)

		fmt.Fprintf(f, "terraform import %s.%s %s\n", tfType, tfName, resourceID)
	}
	return nil
}

// GenerateDestroyPlan creates destruction report.
func (g *Generator) GenerateDestroyPlan(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "CloudSlash Destruction Plan\n")
	fmt.Fprintf(f, "===========================\n\n")

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	totalWaste := 0
	for _, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}
		totalWaste++

		fmt.Fprintf(f, "[%d] %s (%s)\n", node.RiskScore, node.ID, node.Type)
		if reason, ok := node.Properties["Reason"].(string); ok {
			fmt.Fprintf(f, "    Reason: %s\n", reason)
		}

		// Handle S3 Multipart Uploads.
		if node.Type == "AWS::S3::MultipartUpload" {
			bucket, _ := node.Properties["Bucket"].(string)
			key, _ := node.Properties["Key"].(string)
			uploadId, _ := node.Properties["UploadId"].(string)
			fmt.Fprintf(f, "    Command: aws s3api abort-multipart-upload --bucket %s --key \"%s\" --upload-id %s\n", bucket, key, uploadId)
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	fmt.Fprintf(f, "Total Waste Items: %d\n", totalWaste)
	return nil
}

// GenerateFixScript creates state removal script.
func (g *Generator) GenerateFixScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write script header.
	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "set -e\n")
	fmt.Fprintf(f, "set -o pipefail\n\n")

	fmt.Fprintf(f, "# CLOUDSLASH REMEDIATION SCRIPT (%s)\n", version.Current)
	fmt.Fprintf(f, "# Risk Level: SURGICAL (Modifies Terraform State)\n\n")

	fmt.Fprintf(f, `RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${RED}[WARN] This script will remove Zombie resources from your Terraform State.${NC}"
echo "       It does NOT delete the resource from AWS. It only stops Terraform from tracking it."
echo "       This allows you to safely delete the resource in the AWS Console without 'State Drift' errors."
echo ""
read -p "Are you sure you want to proceed? (y/N) " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
fi

# 1. PRE-FLIGHT CHECKS
echo -e "\n${CYAN}[1/3] Pre-flight Checks...${NC}"
if ! command -v terraform &> /dev/null; then
    echo "Error: 'terraform' binary not found."
    exit 1
fi

if [ ! -f "terraform.tfstate" ] && [ ! -d ".terraform" ]; then
    echo "Error: No Terraform state found in current directory."
    exit 1
fi

# 2. SAFETY BACKUP
BACKUP_FILE="tfstate_backup_$(date +%%s).json"
echo -e "${CYAN}[2/3] Creating Safety Backup (${BACKUP_FILE})...${NC}"
terraform state pull > "$BACKUP_FILE"
echo "      Backup secure."

# 3. SURGICAL REMOVAL
echo -e "${CYAN}[3/3] Removing Unused Resources...${NC}"

# --- GENERATED COMMANDS START HERE ---
`)

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	var stateMap map[string]string
	if g.State != nil {
		stateMap = g.State.GetResourceMapping()
	}

	for _, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		// Skip logical upgrades.
		if isGP2, _ := node.Properties["IsGP2"].(bool); isGP2 {
			continue
		}

		tfType := mapResourceTypeToTF(node.Type)
		if tfType == "" {
			continue
		}

		// Find resource address.
		resourceName := ""

		if addr, ok := stateMap[node.ID]; ok {
			resourceName = addr
		} else {
			// Attempt shortened ID match.
			shortID := extractResourceID(node.ID, node.Type)
			if addr, ok := stateMap[shortID]; ok {
				resourceName = addr
			}
		}

		fmt.Fprintf(f, "echo \" -> Removing %s (%s)...\"\n", node.ID, node.Properties["Reason"])
		if resourceName != "" {
			fmt.Fprintf(f, "terraform state rm '%s' || echo \"    (Resource not found in state, skipping)\"\n", resourceName)
		} else {
			fmt.Fprintf(f, "# Warning: Could not resolve address in local state. Suggested command:\n")
			fmt.Fprintf(f, "# terraform state rm %s.<NAME>\n", tfType)
		}
		fmt.Fprintf(f, "\n")
	}

	fmt.Fprintf(f, `# --- GENERATED COMMANDS END HERE ---

echo -e "\n${GREEN}[SUCCESS] State Surgery Complete.${NC}"
echo "Next Step: Run 'terraform plan' to verify the clean state."
`)
	return nil
}

func mapResourceTypeToTF(awsType string) string {
	switch awsType {
	case "AWS::EC2::Instance":
		return "aws_instance"
	case "AWS::EC2::Volume":
		return "aws_ebs_volume"
	case "AWS::EC2::NatGateway":
		return "aws_nat_gateway"
	case "AWS::EC2::EIP":
		return "aws_eip"
	case "AWS::S3::Bucket":
		return "aws_s3_bucket"
	default:
		return ""
	}
}

func sanitizeName(id string) string {
	// Sanitize resource ID for Terraform name.
	parts := strings.Split(id, "/")
	if len(parts) > 1 {
		return strings.ReplaceAll(parts[len(parts)-1], "-", "_")
	}
	return strings.ReplaceAll(id, ":", "_")
}

func extractResourceID(arn, awsType string) string {
	// Extract suffix from ARN.
	parts := strings.Split(arn, "/")
	if len(parts) > 1 {
		return parts[len(parts)-1]
	}
	return arn
}

// GenerateDeletionScript creates deletion script.
func (g *Generator) GenerateDeletionScript(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// Generate Header.
	fmt.Fprintf(f, "#!/bin/bash\n")
	fmt.Fprintf(f, "# CloudSlash Resource Deletion Sequence (%s)\n", version.Current)
	fmt.Fprintf(f, "# WARNING: This script will DESTROY resources. Use with caution.\n\n")

	// Collect Waste Nodes.
	g.Graph.Mu.RLock()
	var wasteNodes []*graph.Node
	for _, n := range g.Graph.Nodes {
		if n.IsWaste && !n.Ignored {
			wasteNodes = append(wasteNodes, n)
		}
	}
	g.Graph.Mu.RUnlock()

	if len(wasteNodes) == 0 {
		fmt.Fprintf(f, "echo 'No waste to delete! System clean.'\n")
		return nil
	}

	// Topological Sort (Reverse Dependency Order).
	// Reverse topological sort for safe deletion.
	
	creationOrder, err := g.Graph.TopologicalSort(wasteNodes)
	if err != nil {
		fmt.Fprintf(f, "# ERROR: Cyclic dependency detected. Manual intervention required.\n")
		fmt.Fprintf(f, "# %v\n", err)
		return nil
	}

	// Reverse order.
	sortedVertices := make([]*graph.Node, len(creationOrder))
	for i, n := range creationOrder {
		sortedVertices[len(creationOrder)-1-i] = n
	}

	// Generate Commands.
	fmt.Fprintf(f, "echo 'Initializing Deletion Sequence...'\n")
	fmt.Fprintf(f, "echo 'Found %d resources to terminate.'\n\n", len(sortedVertices))

	for i, node := range sortedVertices {
		cmd := mapToCLI(node)
		if cmd == "" {
			fmt.Fprintf(f, "# [%d] Manually delete: %s (%s)\n", i+1, node.ID, node.Type)
			continue
		}

		fmt.Fprintf(f, "# [%d] Deleting %s (%s)...\n", i+1, node.ID, node.Type)
		// Wait for network interface detach.
		if node.Type == "AWS::EC2::NetworkInterface" {
			fmt.Fprintf(f, "sleep 5\n")
		}
		fmt.Fprintf(f, "%s\n", cmd)
		// Add error check
		fmt.Fprintf(f, "if [ $? -eq 0 ]; then echo '  -> Deleted.'; else echo '  -> FAILED.'; fi\n\n")
	}

	return nil
}

func mapToCLI(n *graph.Node) string {
	// Extract ID.
	id := extractResourceID(n.ID, n.Type)
	region := "us-east-1"
	if r, ok := n.Properties["Region"].(string); ok {
		region = r
	}

	base := fmt.Sprintf("aws --region %s", region)

	// Generate CLI command by type.
	switch strings.ToLower(n.Type) {
	case "aws::ec2::instance":
		return fmt.Sprintf("%s ec2 terminate-instances --instance-ids %s", base, id)
	case "aws::ec2::volume":
		return fmt.Sprintf("%s ec2 delete-volume --volume-id %s", base, id)
	case "aws::ec2::securitygroup", "aws_security_group":
		return fmt.Sprintf("%s ec2 delete-security-group --group-id %s", base, id)
	case "aws::ec2::networkinterface":
		return fmt.Sprintf("%s ec2 delete-network-interface --network-interface-id %s", base, id)
	case "aws::ec2::natgateway", "aws_nat_gateway":
		return fmt.Sprintf("%s ec2 delete-nat-gateway --nat-gateway-id %s", base, id)
	case "aws::ec2::eip", "aws_eip":
		return fmt.Sprintf("%s ec2 release-address --allocation-id %s", base, id)
	case "aws::s3::bucket", "aws_s3_bucket":
		return fmt.Sprintf("%s s3 rb s3://%s --force", base, id)
	case "aws::lambda::function", "aws_lambda_function":
		parts := strings.Split(n.ID, ":")
		funcName := parts[len(parts)-1]
		if n.Properties["FunctionName"] != nil {
			funcName = n.Properties["FunctionName"].(string)
		}
		return fmt.Sprintf("%s lambda delete-function --function-name %s", base, funcName)
	case "aws::eks::cluster":
		// ID for cluster is usually Name or ARN
		clusterName := extractResourceID(n.ID, n.Type)
		if n.Properties["Name"] != nil {
			clusterName = n.Properties["Name"].(string)
		}
		return fmt.Sprintf("%s eks delete-cluster --name %s", base, clusterName)
	case "aws::eks::nodegroup":
		cluster := "unknown-cluster"
		if n.Properties["ClusterName"] != nil {
			cluster = n.Properties["ClusterName"].(string)
		}
		ngName := extractResourceID(n.ID, n.Type)
		if n.Properties["NodegroupName"] != nil {
			ngName = n.Properties["NodegroupName"].(string)
		}
		return fmt.Sprintf("%s eks delete-nodegroup --cluster-name %s --nodegroup-name %s", base, cluster, ngName)
	case "aws::ecs::service":
		cluster := "default"
		if n.Properties["ClusterArn"] != nil {
			cluster = extractResourceID(n.Properties["ClusterArn"].(string), "cluster")
		}
		svcName := extractResourceID(n.ID, n.Type)
		if n.Properties["Name"] != nil {
			svcName = n.Properties["Name"].(string)
		}
		// Force delete service.
		return fmt.Sprintf("%s ecs delete-service --cluster %s --service %s --force", base, cluster, svcName)
	case "aws::ecs::cluster":
		return fmt.Sprintf("%s ecs delete-cluster --cluster %s", base, id)
	case "aws::rds::dbinstance":
		return fmt.Sprintf("%s rds delete-db-instance --db-instance-identifier %s --skip-final-snapshot", base, id)
	case "aws::elasticloadbalancingv2::loadbalancer":
		return fmt.Sprintf("%s elbv2 delete-load-balancer --load-balancer-arn %s", base, n.ID)
	case "aws::ec2::snapshot":
		
		id := extractResourceID(n.ID, n.Type)
		return fmt.Sprintf("%s ec2 delete-snapshot --snapshot-id %s", base, id)
	case "aws_subnet", "aws::ec2::subnet":
		id := extractResourceID(n.ID, n.Type)
		
		if strings.HasPrefix(id, "arn:") {
			
			parts := strings.Split(id, "/")
			id = parts[len(parts)-1]
		}
		return fmt.Sprintf("%s ec2 delete-subnet --subnet-id %s", base, id)
	case "aws::ec2::vpc", "aws_vpc":
		id := extractResourceID(n.ID, n.Type)
		if strings.HasPrefix(id, "arn:") {
			parts := strings.Split(id, "/")
			id = parts[len(parts)-1]
		}
		return fmt.Sprintf("%s ec2 delete-vpc --vpc-id %s", base, id)
	case "aws::s3::multipartupload":
		// Multipart upload CLI generation not implemented.
		return ""
	}
	return ""
}

// GenerateRestorationPlan creates restoration config.
// Generates Terraform import blocks.
// This allows the user to run 'terraform plan -generate-config-out=backup.tf' to snapshot
// the resource configuration into HCL before deletion.
func (g *Generator) GenerateRestorationPlan(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	g.Graph.Mu.RLock()
	defer g.Graph.Mu.RUnlock()

	fmt.Fprintf(f, "# CloudSlash Lazarus Protocol - Restoration Plan\n")
	fmt.Fprintf(f, "# Generated: %s\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(f, "# INSTRUCTIONS:\n")
	fmt.Fprintf(f, "# 1. Run 'terraform init'\n")
	fmt.Fprintf(f, "# 2. Run 'terraform plan -generate-config-out=lazarus_backup.tf'\n")
	fmt.Fprintf(f, "# 3. This will query AWS and save the CONFIGURATION of these resources to lazarus_backup.tf\n")
	fmt.Fprintf(f, "# 4. If you later need to 'Undo' a deletion, use the code in lazarus_backup.tf to recreate the resource.\n\n")

	fmt.Fprintf(f, "terraform {\n  required_version = \">= 1.5.0\"\n  required_providers {\n    aws = {\n      source = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\n")
	fmt.Fprintf(f, "provider \"aws\" {\n  region = \"%s\" # Default, override via env var if needed\n}\n\n", config.DefaultRegion)

	count := 0
	for _, node := range g.Graph.Nodes {
		if !node.IsWaste {
			continue
		}

		resourceID := extractResourceID(node.ID, node.Type)
		tfType := mapResourceTypeToTF(node.Type)

		if tfType != "" {
			// Sanitize ID.
			safeID := strings.ReplaceAll(resourceID, "-", "_")
			safeID = strings.ReplaceAll(safeID, ".", "_")
			safeID = strings.ReplaceAll(safeID, "/", "_")
			
			fmt.Fprintf(f, "import {\n")
			fmt.Fprintf(f, "  to = %s.restore_%s\n", tfType, safeID)
			fmt.Fprintf(f, "  id = \"%s\"\n", resourceID)
			fmt.Fprintf(f, "}\n\n")
			count++
		}
	}

	if count == 0 {
		fmt.Fprintf(f, "# No supported resources found for restoration.\n")
	}

	return nil
}
